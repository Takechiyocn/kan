## Java锁

### 乐观锁OptimisticLock

    操作数据时非常乐观，认为别人不会同时修改数据，因此不会上锁。
    只在执行更新时判断在此期间数据是否有修改，如有则放弃执行操作

* 实现方式：
  
    * CAS机制

        * CAS(Compare And Swap)操作数:

            * V：需要读写的内存内置V
            * A：进行比较的预期值A
            * B：拟写入的新值B
            
        * 操作逻辑：
          
            ```java
            // compare
            if (V == A) {
                // swap
                V == B;
            } else {
                do nothing;
            }
            ```
          
        * 许多CAS操作都是自旋的，即操作不成功则一直重试直到成功为止
        
        * CAS原子性：
            * Compare和Swap两个操作是CPU支持的原子性操作，即硬件层面支持

    * 版本号机制
      
        * 在数据中增加一个version字段，用于表示该数据的版本号，每当数据修改时，版本号加1

        * 操作逻辑：
          
            * 线程查询数据时，将该数据版本号一起查出来
            * 线程更新数据时，判断当前版本号与之前版本号是否一致(update语句条件)，一致才进行操作
    
        * 实际应用中亦可使用时间戳等标记为版本字段
  
### 悲观锁PessimisticLock

    操作数据时非常悲观，认为别人会同时修改数据，操作数据时直接把数据锁住，直到操作完成后释放锁
    上锁期间别人不能修改数据

* 实现方式：

    * 代码块加锁，如Java的Synchronized关键字
  
    * 对数据加锁，如MySQL中的排它锁queryForUpdate

### 适用场景

乐观锁

1. 简单而言多读场景
   
2. 当竞争不激烈(出现并发冲突概率小)时优先考虑乐观锁

    * CAS
    
        1. 只保证单个变量的原子性操作，即涉及多个变量无法使用CAS
            
            1. 原子性(只能说明原子操作安全)不一定能保证线程安全，需配合volatile保证线程安全
            
        2. 不断重试CPU开销大
               
            1. 引入退出机制
               
            2. 高竞争下避免乐观锁
        3. 实现需硬件层面支持，普通用户无法直接使用，只能借助atomic包
    
    * 版本号机制
      
        1. 如果query针对表1，而update针对表2，很难通过简单版本号实现

悲观锁

1. 简单而言多写场景

2. 当竞争激烈(出现并发冲突概率大)时优先考虑悲观锁，因为乐观锁会不断重试

    * 代码级别锁synchronized：对代码块加锁

乐观锁自身不加锁

1. 乐观锁本身不加锁，只在更新时判断数据是否被其他线程更新了。如AtomicInteger
2. 乐观锁可与悲观锁合作，如版本号机制乐观锁中使用queryForUpdate时，会对数据加锁