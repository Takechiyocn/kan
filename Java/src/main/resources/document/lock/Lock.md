## Java锁

### 乐观锁OptimisticLock

    操作数据时非常乐观，认为别人不会同时修改数据，因此不会上锁。
    只在执行更新时判断在此期间数据是否有修改，如有则放弃执行操作

* 实现方式：
  
    * CAS机制

        * CAS(Compare And Swap)操作数:

            * V：需要读写的内存内置V
            * A：进行比较的预期值A
            * B：拟写入的新值B
            
        * 操作逻辑：
          
            ```java
            // compare
            if (V == A) {
                // swap
                V == B;
            } else {
                do nothing;
            }
            ```
          
        * 许多CAS操作都是自旋的，即操作不成功则一直重试直到成功为止
        
        * CAS原子性：
            * Compare和Swap两个操作是CPU支持的原子性操作，即硬件层面支持

    * 版本号机制
      
        * 在数据中增加一个version字段，用于表示该数据的版本号，每当数据修改时，版本号加1

        * 操作逻辑：
          
            * 线程查询数据时，将该数据版本号一起查出来
            * 线程更新数据时，判断当前版本号与之前版本号是否一致(update语句条件)，一致才进行操作
    
        * 实际应用中亦可使用时间戳等标记为版本字段
  
### 悲观锁PessimisticLock

    操作数据时非常悲观，认为别人会同时修改数据，操作数据时直接把数据锁住，直到操作完成后释放锁
    上锁期间别人不能修改数据

* 实现方式：

    * 代码块加锁，如Java的Synchronized关键字
  
    * 对数据加锁，如MySQL中的排它锁queryForUpdate

### 可重入锁

可多次加锁

* synchronized

* ReentrantLock

### 自旋锁spinlock

为实现保护共享资源(互斥使用)而提出的一种轻量级锁机制

特点：

* 在任何时刻，最多只能有一个持有者，即只能有一个执行单元获得锁

* 调度机制

    * 互斥锁
    
        资源被占用，资源申请者/调用者进入睡眠状态
      
    * 自旋锁
      
        * 资源被占用，资源申请者/调用者不进入睡眠，而是一直循环检测自旋锁持有者是否释放了锁
    
        * 锁被释放，调用者线程立即获取，不需经过唤醒和上下文且切换

### 死锁

如果一个进程里面的每个进程都在等待这个集合中的其他一个进程(包括自身)才能继续执行下去，若无外力他们将无法推进，这种情况就是死锁

![DeadLock.png](images/DeadLock.png)

产生条件：

1. 互斥条件

    1. 进程对所分配到的资源不允许其他进程访问

    2. 其他进程访问时只能等待，直至占有该资源的进程使用完成后释放该资源
    

2. 请求和保持条件

    1. 进程获取一定资源后，又对其他资源发出请求，但该资源被其他进程占有，导致：
    
        1. 请求进程被阻塞
    
        2. 请求进程对自己获取到的资源保持不释放
    
3. 不可剥夺条件

    1. 指进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完成后自己释放
    
4. 环路等待条件

    1. 进程发生思索后，必然存在一个进程-资源之间的环形链
        
解决方法：

1. 预防死锁

    设置一些限制条件，破坏产生死锁的必要条件
    
2. 避免死锁

    在资源分配过程中，使用某种方法避免系统进入不安全状态，从而避免发生死锁
    
3. 检测死锁

    允许死锁的发生，但是通过系统检测之后，采取一些措施，将死锁清除掉

4. 解除死锁

    与检测死锁配合使用

### 适用场景

乐观锁

1. 简单而言多读场景
   
2. 当竞争不激烈(出现并发冲突概率小)时优先考虑乐观锁

    * CAS
    
        1. 只保证单个变量的原子性操作，即涉及多个变量无法使用CAS
            
            1. 原子性(只能说明原子操作安全)不一定能保证线程安全，需配合volatile保证线程安全
            
        2. 不断重试CPU开销大
               
            1. 引入退出机制
               
            2. 高竞争下避免乐观锁
          
        3. 实现需硬件层面支持，普通用户无法直接使用，只能借助atomic包
    
        4. 出现ABA问题(多线程下只关心起始值和最终值，不关心中间过程)
           
            * 线程1读取共享内存的值A，线程1时间片用完，切换到线程B
    
            * 线程2修改该值为B，随后又修改成A
              
            * 切换到线程1，判断A值是预期值，对共享变量进行更新
              
            * 样例：会员充值系统(小于20免费充20)
        
                * 对某一会员卡系统，线程1充了20
    
                * 会员消费20
    
                * 线程2发现余额小于20，又充20，循环
    
    * 版本号机制
      
        1. 如果query针对表1，而update针对表2，很难通过简单版本号实现

悲观锁

1. 简单而言多写场景

2. 当竞争激烈(出现并发冲突概率大)时优先考虑悲观锁，因为乐观锁会不断重试

    * 代码级别锁synchronized：对代码块加锁
    
优先使用顺序：Lock > 同步代码块 > 同步方法

乐观锁自身不加锁

1. 乐观锁本身不加锁，只在更新时判断数据是否被其他线程更新了。如AtomicInteger
2. 乐观锁可与悲观锁合作，如版本号机制乐观锁中使用queryForUpdate时，会对数据加锁